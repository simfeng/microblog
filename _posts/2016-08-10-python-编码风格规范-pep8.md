---
layout: post
title: "python 编码风格规范-PEP8"
date: 2016-08-10 15:17:09
description: python pep8标准，谷歌开源代码标准

categories:
- python
- pep8
- 规范

---

写在前面：基于[PEP 8 -- Style Guide for Python Code](https://www.python.org/dev/peps/pep-0008/)

### 愚蠢的一致性是无脑的妖怪（A Foolish Consistency is the Hobgoblin of Little Minds）

>Guido 的一个主要见解是读代码多过写代码。这里提供指南的意图是强调代码可读性的重要性，并且使大多数 Python 代码保持一致性。如 PEP 20 所述，“Readability counts”。
>
>风格指南是关于一致性的。风格一致对于本指南来说是重要的，对一个项目来说是更重要的，对于一个模块或者方法来说是最重要的。
>
>但是最最重要的是：知道什么时候应该破例–有时候这份风格指南就是不适用。有疑问时，用你最好的判断力，对比其它的例子来确定这是不是最好的情况，并且不耻下问。
>
>特别说明：不要为了遵守这份风格指南而破坏代码的向后兼容性。
>
>这里有一些好的理由去忽略某个风格指南：
>
>- 当应用风格指南的时候使代码更难读了，对于严格依循风格指南的约定去读代码的人也是不应该的。
 - 为了保持和风格指南的一致性同时也打破了现有代码的一致性（可能是历史原因）–虽然这也是一个整理混乱代码的机会（现实中的 XP 风格）。
 - 因为问题代码的历史比较久远，修改代码就没有必要性了。
 - 当代码需要与旧版本的 Python 保持兼容，而旧版 Python 又不支持风格指南中提到的特性的时候。


### 代码排版

### 缩进

每层缩进使用4个空格。

续行缩进

- 与圆括号、中括号、花括号这样的被包裹元素保持垂直对齐，
- 放在 Python 的隐线（注：应该是相对于def的内部块）内部，
- 使用悬挂缩进。使用悬挂缩进的注意事项：第一行不能有参数，用进一步的缩进来把其他行区分开。

good:

```python
# Aligned with opening delimiter.
foo = long_function_name(var_one, var_two,
                         var_three, var_four)

# More indentation included to distinguish this from the rest.
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)

# Hanging indents should add a level.
foo = long_function_name(
    var_one, var_two,
    var_three, var_four)
```

bad:

```python
# 悬浮缩进第一行不能有参数
foo = long_function_name(var_one, var_two,
    var_three, var_four)

# Further indentation required as indentation is not distinguishable.
def long_function_name(
    var_one, var_two, var_three,
    var_four):
    print(var_one)
```


在多行结构中的右圆括号、右中括号、右大括号应该放在最后一行的第一个非空白字符的正下方，如下所示：

```python
my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
    )
```

或者放在多行结构的起始行的第一个字符正下方，如下：

```python
my_list = [
    1, 2, 3,
    4, 5, 6,
]
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
)
```

### 每行最大长度

限制每行的最大长度为79个字符。

对于那些约束很少的文本结构（文档字符串或注释）的长块，应该限制每行长度为72个字符。

限制编辑窗口的宽度使并排打开两个窗口成为可能，使用通过代码审查工具时，也能很好的通过相邻列展现不同代码版本。

把行提升到80~100的长度是可接受的（实际最大长度为99个字符），注释和文档字符串的长度还是建议在72个字符内。

Python 标准库是非常专业的，限制最大代码长度为79个字符（注释和文档字符串最大长度为72个字符）。

首选的换行方式是在`括号（小中大）内隐式换行`（非续行符`\`）。长行应该在括号表达式的包裹下换行。这比`反斜杠`作为续行符更好。

```python
long_string = ('I am a long string '
               'I am a long string')
```

反斜杠有时仍然适用。例如，多个很长的`with`语句不能使用隐式续行，因此反斜杠是可接受的。

```python
with open('/path/to/some/file/you/want/to/read') as file_1, \
     open('/path/to/some/file/being/written', 'w') as file_2:
    file_2.write(file_1.read())
```

__确保续行的缩进是恰到好处的。遇到二元操作符，首选的断行位置是操作符的后面而不是前面__。这有一些例子：

```python
class Rectangle(Blob):

    def __init__(self, width, height,
                 color='black', emphasis=None, highlight=0):
        if (width == 0 and height == 0 and
                color == 'red' and emphasis == 'strong' or
                highlight > 100):
            raise ValueError("sorry, you lose")
        if width == 0 and height == 0 and (color == 'red' or
                                           emphasis is None):
            raise ValueError("I don't think so -- values are %s, %s" %
                             (width, height))
        Blob.__init__(self, width, height,
                      color, emphasis, highlight)
```

### 空行

顶级函数和类定义上下使用两个空行分隔。

类内的方法定义使用一个空行分隔。

在函数中使用空白行（有节制的）来表明逻辑部分。

### 导包

import不同的模块应该独立一行，如：

good:

```python
import os
import sys
```

bad:

```python
import sys, os
```

这样也是可行的：

```python
from subprocess import Popen, PIPE
```


import语句分组顺序如下：

1. 导入标准库模块
2. 导入相关第三方库模块
3. 导入当前应用程序/库模块
4. 每组之间应该用空行分开。

然后用`__all__`声明本文件内的模块。

推荐绝对导入，它们通常是更可读的，并且在错误的包系统配置（如一个目录包含一个以os.path结尾的包）下有良好的行为倾向（至少有更清晰的错误消息）：

```python
import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example
```

标准库代码应该避免复杂的包结构，并且永远使用绝对导入。


从一个包含类的模块导入类时，这样写通常是可行的：

```python
from myclass import MyClass
from foo.bar.yourclass import YourClass
```

如果上面的方式会本地导致命名冲突，则这样写：

```python
import myclass
import foo.bar.yourclass
```

以`myclass.MyClass`和`foo.bar.yourclass.YourClass`这样的方式使用。

__应该避免通配符导入（`from <module> import *`）__

### 表达式和语句中的空格

避免在下列情况中使用多余的空格：

- 与括号保持紧凑（小括号、中括号、大括号）：

```python
Yes: spam(ham[1], {eggs: 2})
No:  spam( ham[ 1 ], { eggs: 2 } )
```

- 与后面的逗号、分号或冒号保持紧凑：

```python
Yes: if x == 4: print x, y; x, y = y, x
No:  if x == 4 : print x , y ; x , y = y , x
```

- 切片内的冒号就像二元操作符一样，任意一侧应该被等同对待（把它当做一个极低优先级的操作）
在一个可扩展的切片中，冒号两侧必须有相同的空格数量。例外：切片参数省略时，空格也省略。

good：

```python
ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
ham[lower:upper], ham[lower:upper:], ham[lower::step]
ham[lower+offset : upper+offset]
ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
ham[lower + offset : upper + offset]
```

bad:

```python
ham[lower + offset:upper + offset]
ham[1: 9], ham[1 :9], ham[1:9 :3]
ham[lower : : upper]
ham[ : upper]
```

- 函数名与其后参数列表的左括号应该保持紧凑：

```python
Yes: spam(1)
No:  spam (1)
```

- 与切片或索引的左括号保持紧凑：

```python
Yes: dct['key'] = lst[index]
No:  dct ['key'] = lst [index]
```

- 在赋值操作符（或其它）的两侧保持多余一个的空格：

good:

```python
x = 1
y = 2
long_variable = 3
```

bad:

```python
x             = 1
y             = 2
long_variable = 3
```

__其他建议__

- 总是在这些二元操作符的两侧加入一个空格：赋值(=)，增量赋值(+=, -= etc.)，比较(==, <, >, !=, <>, <=, >=, in, not in, is, is not)，布尔运算(and, or, not)。
- 在不同优先级之间，考虑在更低优先级的操作符两侧插入空格。用你自己的判断力；但不要使用超过一个空格，并且在二元操作符的两侧有相同的空格数。

good：

```python
i = i + 1
submitted += 1
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)
```

bad:

```python
i=i+1
submitted +=1
x = x * 2 - 1
hypot2 = x * x + y * y
c = (a + b) * (a - b)
```

- 不要在关键值参数或默认值参数的等号两边加入空格。

good：

```python
def complex(real, imag=0.0):
    return magic(r=real, i=imag)
```

bad:

```python
def complex(real, imag = 0.0):
    return magic(r = real, i = imag)
```

- 打消使用复合语句（多条语句在同一行）的念头。

good:

```python
if foo == 'blah':
    do_blah_thing()
do_one()
do_two()
do_three()
```

 宁可不：

```python
if foo == 'blah': do_blah_thing()
do_one(); do_two(); do_three()
```

- 有时候把 if/for/while 和一个小的主体放在同一行也是可行的，千万不要在有多条语句的情况下这样做。此外，还要避免折叠，例如长行。

宁可不：

```python
if foo == 'blah': do_blah_thing()
for x in lst: total += x
while t < 10: t = delay()
```

绝对不：

```python
if foo == 'blah': do_blah_thing()
else: do_non_blah_thing()

try: something()
finally: cleanup()

do_one(); do_two(); do_three(long, argument,
                             list, like, this)

if foo == 'blah': one(); two(); three()
```

### 命名约定


#### 常用命名风格

- b (一个小写字母)
- B (一个大写字母)
- lowercase
- lower_case_with_underscores
- UPPERCASE
- UPPER_CASE_WITH_UNDERSCORES
- CapitalizedWords (又叫 CapWords，或者 CamelCase(骆驼命名法) – 如此命名因为字母看起来崎岖不平)。有时候也叫 StudlyCaps。
- mixedCase (和上面不同的是首字母小写)
- _single_leading_underscore ：仅内部使用的标识，如from M import *不会导入像这样一下划线开头的对象。
- single_trailing_underscore_ : 通常是为了避免与 Python 规定的关键字冲突。

#### 规定：命名约定

- 应该避免的名字

永远不要使用单个字符l(小写字母 el)，O(大写字母 oh)，或I(大写字母 eye)作为变量名。

在一些字体中，这些字符是无法和数字1和0区分开的。试图使用l时用L代替。

- 包和模块名

模块名应该短，且全小写。如果能改善可读性，可以使用下划线。Python 的包名也应该短，全部小写，但是不推荐使用下划线。

- 类名

类名通常使用 CapWords 约定。

- 异常名

因为异常应该是类，所以类名约定在这里适用。但是，你应该用Error作为你的异常名的后缀（异常实际上是一个错误）。

- 全局变量名

若被设计的模块可以通过`from M import *`来使用，它应该使用`__all__`机制来表明那些可以可导出的全局变量，或者使用下划线前缀的全局变量表明其是模块私有的。

- 函数名

函数名应该是小写的，有必要的话用下划线来分隔单词提高可读性。

- 函数和方法参数

总是使用self作为实例方法的第一个参数。

总是使用cls作为类方法的第一个参数。

如果函数参数与保留关键字冲突，通常最好在参数后面添加一个尾随的下划线，而不是使用缩写或胡乱拆减。因此class_比clss要好。（或许避免冲突更好的方式是使用近义词）

- 方法名和实例变量

用函数名的命名规则：全部小写，用下划线分隔单词提高可读性。

用一个且有一个前导的下划线来表明非公有的方法和实例变量。

- 常量

常量通常是模块级的定义，全部大写，单词之间以下划线分隔。例如MAX_OVERFLOW和TOTAL。
